import * as aj from '../animatedJava'
import nbtlint from '../dependencies/nbtlint/docs/nbt-lint'

import {
	CustomError,
	fixIndent,
	format,
	JsonText,
	safeFunctionName,
	translate,
	store,
} from '../util'
import { NBT, NBTType } from '../util/minecraft/nbt'

interface animationExporterSettings {
	modelTag: string
	rootTag: string
	allBonesTag: string
	individualBoneTag: string
	rootEntityType: string
	boneType: 'aecStack' | 'armorStand'
	internalScoreboardObjective: string
	idScoreboardObjective: string
	frameScoreboardObjective: string
	exportMode: 'datapack' | 'mcb'
	mcbFilePath: string | undefined
	dataPackFilePath: string | undefined
	markerArmorStands: boolean
}

interface MCBConfig {
	dev: boolean
	header: string
	internalScoreboard: string
	generatedDirectory: string
	rootNamespace?: string
	defaultNamespace?: string
	[index: string]: any
}

interface entityTypes {
	bone: string
	root: string
	boneRoot: string
	boneDisplay?: string
}

const HEAD_Y_OFFSET = -1.813

async function createMCFile(
	bones: aj.BoneObject,
	models: aj.ModelObject,
	animations: aj.Animations,
	settings: aj.Settings,
	variantModels: aj.VariantModels,
	variantTextureOverrides: aj.VariantTextureOverrides,
	variantTouchedModels: aj.variantTouchedModels
): Promise<string> {
	const ajSettings = settings.animatedJava
	const exporterSettings: animationExporterSettings =
		settings.animatedJava_exporter_animationExporter
	const projectName = safeFunctionName(ajSettings.projectName)

	const staticAnimationUuid = store.get('static_animation_uuid')
	const staticFrame = animations[staticAnimationUuid].frames[0].bones
	const staticDistance = animations[staticAnimationUuid].maxDistance

	const FILE: string[] = []

	const rootExeErrorJsonText = new JsonText([
		'',
		{ text: 'AJ', color: 'green' },
		{ text: ' ? ', color: 'light_purple' },
		{ text: 'Error ?', color: 'red' },
		'\n',
		{ text: '%functionName', color: 'blue' },
		' ',
		{ text: 'must be executed as ', color: 'gray' },
		{ text: `aj.${projectName}.root`, color: 'light_purple' },
	]).toString()

	const scoreboards = {
		id: exporterSettings.idScoreboardObjective,
		internal: exporterSettings.internalScoreboardObjective,
		frame: exporterSettings.frameScoreboardObjective,
	}

	const tags = {
		model: format(exporterSettings.modelTag, {
			modelName: projectName,
		}),
		root: format(exporterSettings.rootTag, {
			modelName: projectName,
		}),
		allBones: format(exporterSettings.allBonesTag, {
			modelName: projectName,
		}),
		individualBone: format(exporterSettings.individualBoneTag, {
			modelName: projectName,
		}),
	}

	const entityTypes: entityTypes = {
		bone: `#${projectName}:bone_entities`,
		root: 'minecraft:marker',
		boneRoot: 'minecraft:area_effect_cloud',
		boneDisplay: 'minecraft:armor_stand',
	}

	const CONFIG: MCBConfig = {
		dev: false,
		header: '#Code generated by Animated Java (https://animated-java.dev/)',
		internalScoreboard: scoreboards.internal,
		generatedDirectory: 'zzz',
	}

	FILE.push(`
		function install {
			${Object.entries(scoreboards)
				.map(([k, v]) => `scoreboard objectives add ${v}`)
				.join('\n')}
		}
	`)

	//? Bone Entity Type
	FILE.push(`
		entities bone_entities {
			${entityTypes.boneRoot}
			${entityTypes.boneDisplay}
		}
	`)

	//? Remove Dir
	// prettier-ignore
	FILE.push(`
		dir remove {
			function all {
				kill @e[type=${entityTypes.root},tag=${tags.model}]
				kill @e[type=${entityTypes.bone},tag=${tags.model}]
			}
			function this {
				execute (if entity @s[tag=${tags.root}] at @s) {
					scoreboard players operation # ${scoreboards.id} = @s ${scoreboards.id}
					execute as @e[type=${entityTypes.bone},tag=${tags.model},distance=..${staticDistance}] if score @s ${scoreboards.id} = # ${scoreboards.id} run kill @s
					kill @s
				} else {
					tellraw @s ${rootExeErrorJsonText.replace('%functionName', `${projectName}:remove/all`)}
				}
			}
		}
	`)

	//? Summon Dir
	class Summon {
		boneName: string
		bone: aj.AnimationFrameBone
		model: aj.Model
		customModelData: number
		constructor(boneName: string, bone: aj.AnimationFrameBone) {
			this.boneName = boneName
			this.bone = bone
			this.model = models[boneName]
			this.resetCustomModelData()
			console.log(this)
			console.log(this.nbt)
			console.log(this.nbt.toString())
		}

		resetCustomModelData() {
			this.customModelData = this.model.aj.customModelData
		}

		get nbt(): NBT<NBTType.COMPOUND> {
			// prettier-ignore
			return NBT.Compound()
			.Int('Age', -2147483648)
			.Int('Duration', -1)
			.Int('WaitTime', -2147483648)
			.ListOf('Tags', NBTType.STRING, [
				'new',
				tags.model,
				tags.allBones,
				tags.individualBone.replace('%boneName', this.boneName),
			])
			.ListOf('Passengers', NBTType.COMPOUND, [
				NBT.Compound()
					.String('id', entityTypes.boneDisplay)
					.ListOf('Tags', NBTType.STRING, [
						'new',
						tags.model,
						tags.allBones,
						tags.individualBone.replace('%boneName', this.boneName),
					])
					.ListOf('ArmorItems', NBTType.COMPOUND, [
						{}, {}, {},
						NBT.Compound()
							.String('id', ajSettings.rigItem)
							.Byte('Count', 1)
							.Compound('tag', {
								CustomModelData: NBT.Int(this.customModelData)
							})
					])
					.Byte('Invisible', 1)
					.Byte('Marker', Number(exporterSettings.markerArmorStands))
					.Byte('NoGravity', 1)
			])
		}

		get pos() {
			return {
				x: this.bone.pos.x,
				y: this.bone.pos.y + HEAD_Y_OFFSET,
				z: this.bone.pos.z,
			}
		}

		toString() {
			const pos = Object.values(this.pos)
				.map((v) => `^${v}`)
				.join(' ')
			return `summon ${entityTypes.boneRoot} ${pos} ${this.nbt}`
		}
	}

	FILE.push(`dir summon {`)

	const summons = []
	for (const [boneName, bone] of Object.entries(staticFrame)) {
		if (!bone.exported) continue
		console.log(boneName)
		const summon = new Summon(boneName, bone)
		summons.push(summon)
	}

	for (const [variantName, variant] of Object.entries(variantModels)) {
		for (const summon of summons) {
			if (variant[summon.boneName]) {
				summon.customModelData = variant[summon.boneName].aj.customModelData
			} else {
				summon.resetCustomModelData()
			}
		}
		// prettier-ignore
		FILE.push(`
			function ${variantName} {
				summon minecraft:marker ~ ~ ~ {Tags:['new', ${tags.model}, ${tags.root}]}
				execute as @e[type=minecraft:marker,tag=${tags.root},tag=new,distance=..1,limit=1] at @s rotated ~ 0 run {
					execute store result score @s ${scoreboards.id} run scoreboard players add .aj.last_id ${scoreboards.internal} 1
					${summons.map(v => v.toString()).join('\n')}
					execute as @e[type=${entityTypes.bone},tag=${tags.model},tag=new,distance=..${staticDistance}] positioned as @s run {
						scoreboard players operation @s ${scoreboards.id} = .aj.last_id ${scoreboards.internal}
						tp @s ~ ~ ~ ~ ~
						tag @s remove new
					}
					tag @s remove new
				}
			}
		`)
	}

	FILE.push(`}`)

	return fixIndent(FILE)
}

async function animationExport(data: any) {
	const mcFile = await createMCFile(
		data.bones,
		data.models,
		data.animations,
		data.settings,
		data.variantModels,
		data.variantTextureOverrides,
		data.variantTouchedModels
	)

	if (!data.settings.animatedJava_exporter_animationExporter.mcbFilePath) {
		let d = new Dialog({
			title: translate(
				'animatedJava_exporter_animationExporter.popup.error.mcbFilePathNotDefined.title'
			),
			id: '',
			lines: translate(
				'animatedJava_exporter_animationExporter.popup.error.mcbFilePathNotDefined.body'
			)
				.split('\n')
				.map((line: string) => `<p>${line}</p>`),
			onConfirm() {
				d.hide()
			},
			onCancel() {
				d.hide()
			},
		}).show()
		throw new CustomError({ silent: true })
	}

	console.log('mcFile:', mcFile)
	Blockbench.writeFile(
		data.settings.animatedJava_exporter_animationExporter.mcbFilePath,
		{
			content: mcFile,
			custom_writer: null,
		}
	)

	Blockbench.showQuickMessage('Model Exported Successfully')
}

const Exporter = (AJ: any) => {
	AJ.settings.registerPluginSettings(
		'animatedJava_exporter_animationExporter',
		{
			rootEntityType: {
				type: 'text',
				default: 'minecraft:marker',
				populate() {
					return 'minecraft:marker'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			markerArmorStands: {
				type: 'checkbox',
				default: true,
				populate() {
					return true
				},
				isValid(value: any) {
					return typeof value === 'boolean'
				},
			},
			modelTag: {
				type: 'text',
				default: 'aj.%modelName',
				populate() {
					return 'aj.%modelName'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			rootTag: {
				type: 'text',
				default: 'aj.%modelName.root',
				populate() {
					return 'aj.%modelName.root'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			allBonesTag: {
				type: 'text',
				default: 'aj.%modelName.bone',
				populate() {
					return 'aj.%modelName.bone'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			boneModelDisplayTag: {
				type: 'text',
				default: 'aj.%modelName.bone_display',
				populate() {
					return 'aj.%modelName.bone_display'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			individualBoneTag: {
				type: 'text',
				default: 'aj.%modelName.%boneName',
				populate() {
					return 'aj.%modelName.%boneName'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			internalScoreboardObjective: {
				type: 'text',
				default: 'aj.i',
				populate() {
					return 'aj.i'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			idScoreboardObjective: {
				type: 'text',
				default: 'aj.id',
				populate() {
					return 'aj.id'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			frameScoreboardObjective: {
				type: 'text',
				default: 'aj.frame',
				populate() {
					return 'aj.frame'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			exportMode: {
				type: 'select',
				default: 'mcb',
				options: {
					vanilla:
						'animatedJava_exporter_animationExporter.setting.exportMode.vanilla.name',
					mcb: 'animatedJava_exporter_animationExporter.setting.exportMode.mcb.name',
				},
				populate() {
					return 'mcb'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			mcbFilePath: {
				type: 'filepath',
				default: '',
				props: {
					dialogOpts: {
						defaultPath: Project.name + '.mc',
						promptToCreate: true,
						properties: ['openFile'],
					},
				},
				populate() {
					return ''
				},
				isValid(value: any) {
					return true
				},
				isVisible(settings: any) {
					return (
						settings.animatedJava_exporter_animationExporter
							.exportMode === 'mcb'
					)
				},
				dependencies: [
					'animatedJava_exporter_animationExporter.exportMode',
				],
			},
			dataPackPath: {
				type: 'filepath',
				default: '',
				props: {
					target: 'folder',
					dialogOpts: {
						promptToCreate: true,
						properties: ['openDirectory'],
					},
				},
				populate() {
					return ''
				},
				isValid(value: any) {
					return true
				},
				isVisible(settings: any) {
					return (
						settings.animatedJava_exporter_animationExporter
							.exportMode === 'vanilla'
					)
				},
				dependencies: [
					'animatedJava_exporter_animationExporter.exportMode',
				],
			},
		}
	)
	AJ.registerExportFunc('animationExporter', function () {
		AJ.build(
			(data: any) => {
				console.log('Input Data:', data)
				animationExport(data)
			},
			{
				generate_static_animation: true,
			}
		)
	})
}
if (Reflect.has(window, 'ANIMATED_JAVA')) {
	Exporter(window['ANIMATED_JAVA'])
} else {
	// @ts-ignore
	Blockbench.on('animated-java-ready', Exporter)
}
