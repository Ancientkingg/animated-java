import * as aj from '../animatedJava'
import nbtlint from '../dependencies/nbtlint/docs/nbt-lint'

import {
	CustomError,
	fixIndent,
	format,
	JsonText,
	safeFunctionName,
	translate,
	store,
	roundToN,
	generateTree,
	removeKeyGently,
} from '../util'
import { NBT, NBTType } from '../util/minecraft/nbt'

interface animationExporterSettings {
	allBonesTag: string
	animatingFlagScoreboardObjective: string
	animationLoopModeScoreboardObjective: string
	boneModelDisplayTag: string
	boneType: 'aecStack' | 'armorStand'
	dataPackFilePath: string | undefined
	exportMode: 'datapack' | 'mcb'
	frameScoreboardObjective: string
	idScoreboardObjective: string
	individualBoneTag: string
	internalScoreboardObjective: string
	markerArmorStands: boolean
	mcbFilePath: string | undefined
	modelTag: string
	rootEntityType: string
	rootTag: string
}

interface MCBConfig {
	dev: boolean
	header: string
	internalScoreboard: string
	generatedDirectory: string
	rootNamespace?: string
	defaultNamespace?: string
	[index: string]: any
}

interface EntityTypes {
	bone: string
	root: string
	boneRoot: string
	boneDisplay?: string
}

interface Tags {
	model: string
	root: string
	allBones: string
	individualBone: string
	boneDisplay: string
}

interface Scoreboards {
	id: string
	internal: string
	frame: string
	animatingFlag: string
	animationLoopMode: string
}

async function createMCFile(
	bones: aj.BoneObject,
	models: aj.ModelObject,
	animations: aj.Animations,
	settings: aj.Settings,
	variantModels: aj.VariantModels,
	variantTextureOverrides: aj.VariantTextureOverrides,
	variantTouchedModels: aj.variantTouchedModels
): Promise<string> {
	const ajSettings = settings.animatedJava
	const exporterSettings: animationExporterSettings =
		settings.animatedJava_exporter_animationExporter
	const projectName = safeFunctionName(ajSettings.projectName)

	const HEAD_Y_OFFSET = -1.813
	if (!exporterSettings.markerArmorStands) HEAD_Y_OFFSET + 0.4

	const staticAnimationUuid = store.get('static_animation_uuid')
	const staticFrame = animations[staticAnimationUuid].frames[0].bones
	const staticDistance = roundToN(
		animations[staticAnimationUuid].maxDistance + -HEAD_Y_OFFSET,
		1000
	)
	const maxDistance = roundToN(
		Object.values(animations).reduce((o, n) => {
			return Math.max(o, n.maxDistance)
		}, -Infinity) + -HEAD_Y_OFFSET,
		1000
	)
	animations = removeKeyGently(staticAnimationUuid, animations)
	console.log(animations)

	const FILE: string[] = []

	const rootExeErrorJsonText = new JsonText([
		'',
		{ text: 'AJ', color: 'green' },
		{ text: ' → ', color: 'light_purple' },
		{ text: 'Error ☠', color: 'red' },
		'\n',
		{ text: '%functionName', color: 'blue' },
		' ',
		{ text: 'must be executed as ', color: 'gray' },
		{ text: `aj.${projectName}.root`, color: 'light_purple' },
	]).toString()

	const scoreboards = Object.fromEntries(
		Object.entries({
			id: exporterSettings.idScoreboardObjective,
			internal: exporterSettings.internalScoreboardObjective,
			frame: exporterSettings.frameScoreboardObjective,
			animatingFlag: exporterSettings.animatingFlagScoreboardObjective,
			animationLoopMode: exporterSettings.animationLoopModeScoreboardObjective
		}).map(([k, v]) => [
			k,
			format(v, {
				projectName,
			}),
		])
	) as Scoreboards

	const tags = Object.fromEntries(
		Object.entries({
			model: exporterSettings.modelTag,
			root: exporterSettings.rootTag,
			allBones: exporterSettings.allBonesTag,
			individualBone: exporterSettings.individualBoneTag,
			boneDisplay: exporterSettings.boneModelDisplayTag,
		}).map(([k, v]) => [k, format(v, { projectName })])
	) as Tags

	const entityTypes: EntityTypes = {
		bone: `#${projectName}:bone_entities`,
		root: 'minecraft:marker',
		boneRoot: 'minecraft:area_effect_cloud',
		boneDisplay: 'minecraft:armor_stand',
	}

	const CONFIG: MCBConfig = {
		dev: false,
		header: '#Code generated by Animated Java (https://animated-java.dev/)',
		internalScoreboard: scoreboards.internal,
		generatedDirectory: 'zzz',
	}

	FILE.push(`
		function install {
			${Object.entries(scoreboards)
				.map(([k, v]) => `scoreboard objectives add ${v}`)
				.join('\n')}
		}
	`)

	//? Bone Entity Type
	FILE.push(`
		entities bone_entities {
			${entityTypes.boneRoot}
			${entityTypes.boneDisplay}
		}
	`)

	//? Remove Dir
	// prettier-ignore
	FILE.push(`
		dir remove {
			function all {
				kill @e[type=${entityTypes.root},tag=${tags.model}]
				kill @e[type=${entityTypes.bone},tag=${tags.model}]
			}
			function this {
				execute (if entity @s[tag=${tags.root}] at @s) {
					scoreboard players operation # ${scoreboards.id} = @s ${scoreboards.id}
					execute as @e[type=${entityTypes.bone},tag=${tags.model},distance=..${staticDistance}] if score @s ${scoreboards.id} = # ${scoreboards.id} run kill @s
					kill @s
				} else {
					tellraw @s ${rootExeErrorJsonText.replace('%functionName', `${projectName}:remove/all`)}
				}
			}
		}
	`)

	{
		//? Summon Dir
		class Summon {
			boneName: string
			bone: aj.AnimationFrameBone
			model: aj.Model
			customModelData: number
			constructor(boneName: string, bone: aj.AnimationFrameBone) {
				this.boneName = boneName
				this.bone = bone
				this.model = models[boneName]
				this.resetCustomModelData()
				console.log(this)
				console.log(this.nbt)
				console.log(this.nbt.toString())
			}

			resetCustomModelData() {
				this.customModelData = this.model.aj.customModelData
			}

			get nbt(): NBT<NBTType.COMPOUND> {
				// prettier-ignore
				return NBT.Compound()
				.Int('Age', -2147483648)
				.Int('Duration', -1)
				.Int('WaitTime', -2147483648)
				.ListOf('Tags', NBTType.STRING, [
					'new',
					tags.model,
					tags.allBones,
					tags.individualBone.replace('%boneName', this.boneName),
				])
				.ListOf('Passengers', NBTType.COMPOUND, [
					NBT.Compound()
						.String('id', entityTypes.boneDisplay)
						.ListOf('Tags', NBTType.STRING, [
							'new',
							tags.model,
							tags.allBones,
							tags.individualBone.replace('%boneName', this.boneName),
							tags.boneDisplay
						])
						.ListOf('ArmorItems', NBTType.COMPOUND, [
							{}, {}, {},
							NBT.Compound()
								.String('id', ajSettings.rigItem)
								.Byte('Count', 1)
								.Compound('tag', {
									CustomModelData: NBT.Int(this.customModelData)
								})
						])
						.Byte('Invisible', 1)
						.Byte('Marker', Number(exporterSettings.markerArmorStands))
						.Byte('NoGravity', 1)
						.Compound('Pose', {
							Head: NBT.ListOf(NBTType.FLOAT, [
								this.bone.rot.x,
								this.bone.rot.y,
								this.bone.rot.z
							])
						})
				])
			}

			get pos(): { x: number; y: number; z: number } {
				return {
					x: this.bone.pos.x,
					y: this.bone.pos.y + HEAD_Y_OFFSET,
					z: this.bone.pos.z,
				}
			}

			toString() {
				const pos = Object.values(this.pos)
					.map((v) => `^${v}`)
					.join(' ')
				return `summon ${entityTypes.boneRoot} ${pos} ${this.nbt}`
			}
		}

		FILE.push(`dir summon {`)

		const summons = []
		for (const [boneName, bone] of Object.entries(staticFrame)) {
			if (!bone.exported) continue
			console.log(boneName)
			const summon = new Summon(boneName, bone)
			summons.push(summon)
		}

		for (const [variantName, variant] of Object.entries(variantModels)) {
			for (const summon of summons) {
				if (variant[summon.boneName]) {
					summon.customModelData =
						variant[summon.boneName].aj.customModelData
				} else {
					summon.resetCustomModelData()
				}
			}
			// prettier-ignore
			FILE.push(`
				function ${variantName} {
					summon minecraft:marker ~ ~ ~ {Tags:['new', ${tags.model}, ${tags.root}]}
					execute as @e[type=minecraft:marker,tag=${tags.root},tag=new,distance=..1,limit=1] at @s rotated ~ 0 run {
						execute store result score @s ${scoreboards.id} run scoreboard players add .aj.last_id ${scoreboards.internal} 1
						${summons.map(v => v.toString()).join('\n')}
						execute as @e[type=${entityTypes.bone},tag=${tags.model},tag=new,distance=..${staticDistance}] positioned as @s run {
							scoreboard players operation @s ${scoreboards.id} = .aj.last_id ${scoreboards.internal}
							tp @s ~ ~ ~ ~ ~
							tag @s remove new
						}
						tag @s remove new
					}
				}
			`)
		}
		FILE.push(`}`)
	}

	//? Set Variant Dir
	const variantBoneModifier = `data modify entity @s[tag=${tags.individualBone}] ArmorItems[-1].tag.CustomModelData set value %customModelData`

	FILE.push(`dir set_variant {`)
	for (const [variantName, variant] of Object.entries(variantModels)) {
		const thisVariantTouchedModels = { ...variantTouchedModels, ...variant }
		const commands = Object.entries(thisVariantTouchedModels).map(
			([k, v]) =>
				format(variantBoneModifier, {
					customModelData: v.aj.customModelData,
					boneName: k,
				})
		)

		// prettier-ignore
		FILE.push(`
			function ${variantName} {
				execute (if entity @s[tag=${tags.root}] at @s) {
					scoreboard players operation .this aj.id = @s aj.id
					execute as @e[type=${entityTypes.boneDisplay},tag=${tags.allBones},distance=..${maxDistance}] if score @s aj.id = .this aj.id run {
						${commands.join('\n')}
					}
				} else {
					tellraw @s ${rootExeErrorJsonText.replace('%functionName',`${projectName}:set_variant/${variantName}`)}
				}
			}
		`)
	}

	FILE.push(`}`)

	{
		//? Reset function
		const boneBaseModifier = `tp @s[tag=${tags.individualBone}] ^%x ^%y ^%z`
		const boneDisplayModifier = `data modify entity @s[tag=${tags.individualBone}] Pose.Head set value [%xf,%yf,%zf]`
		const baseModifiers: string[] = []
		const displayModifiers: string[] = []

		for (const [boneName, bone] of Object.entries(staticFrame)) {
			const baseModifier = format(boneBaseModifier, {
				boneName,
				x: bone.pos.x,
				y: bone.pos.y + HEAD_Y_OFFSET,
				z: bone.pos.z,
			})
			const displayModifier = format(boneDisplayModifier, {
				boneName,
				x: bone.rot.x,
				y: bone.rot.y,
				z: bone.rot.z,
			})
			baseModifiers.push(baseModifier)
			displayModifiers.push(displayModifier)
		}

		// prettier-ignore
		FILE.push(`
			# Resets the model to it's initial summon position/rotation and stops all active animations
			function reset {
				# Make sure this function has been ran as the root entity
				execute(if entity @s[tag=${tags.root}] at @s) {
					# Remove all animation tags
					${'tag @s remove aj.example.anim.example_1'}
					# Reset animation time
					scoreboard players set @s ${scoreboards.frame} 0

					scoreboard players operation .this ${scoreboards.id} = @s ${scoreboards.id}
					execute as @e[type=${entityTypes.boneRoot},tag=${tags.allBones},distance=..${maxDistance}] if score @s ${scoreboards.id} = .this ${scoreboards.id} run {
						${baseModifiers.join('\n')}
					}
					execute as @e[type=${entityTypes.boneDisplay},tag=${tags.allBones},distance=..${maxDistance}] if score @s ${scoreboards.id} = .this ${scoreboards.id} run {
						${displayModifiers.join('\n')}
					}

				# If this entity is not the root
				} else {
					tellraw @s ${rootExeErrorJsonText.replace('%functionName',`${projectName}:reset`)}
				}
			}
		`)
	}

	{
		//? Animation Loop function
		const animationRunCommand = `execute if entity @s[tag=aj.${projectName}.anim.%animationName] run function ${projectName}:animations/%animationName/next_frame`
		const animationRunCommands = Object.values(animations).map((v) =>
			format(animationRunCommand, { animationName: v.name })
		)
		// prettier-ignore
		FILE.push(`
			function animation_loop {
				# Schedule clock
				schedule function ${projectName}:animation_loop 1t
				# Set anim_loop active flag to true
				scoreboard players set .aj.anim ${scoreboards.animatingFlag} 1
				# Reset animating flag (Used internally to check if any animations have ticked during this tick)
				scoreboard players set .aj.animation ${scoreboards.animatingFlag} 0
				# Run animations that are active on the entity
				execute as @e[type=${entityTypes.root},tag=${tags.root}] run{
					${animationRunCommands.join('\n')}
				}
				# Stop the anim_loop clock if no models are animating
				execute if score .aj.animation ${scoreboards.animatingFlag} matches 0 run {
					# Stop anim_loop shedule clock
					schedule clear ${projectName}:animation_loop
					# Set anim_loop active flag to false
					scoreboard players set .aj.anim ${scoreboards.animatingFlag} 0
				}
			}
		`)
	}

	{
		//? Animation Dir
		FILE.push(`dir animations {`)

		for (const animation of Object.values(animations)) {
			const thisAnimationLoopMode = format(scoreboards.animationLoopMode, {
				animationName: animation.name
			})
			FILE.push(`dir ${animation.name} {`)
			// prettier-ignore
			FILE.push(`# Starts the animation from the first frame
				function play {
					# Make sure this function has been ran as the root entity
					execute(if entity @s[tag=${tags.root}] at @s) {
						# Add animation tag
						tag @s add aj.${projectName}.anim.${animation.name}
						# Reset animation time
						scoreboard players set @s ${scoreboards.frame} 0
						# Start the animation loop if not running
						execute if score .aj.animation ${scoreboards.animatingFlag} matches 0 run function ${projectName}:animation_loop
					# If this entity is not the root
					} else {
						tellraw @s ${rootExeErrorJsonText.replace('%functionName',`${projectName}:animations/${animation.name}/play`)}
					}
				}`
			)
			// prettier-ignore
			FILE.push(`# Stops the animation and resets to first frame
				function stop {
					# Make sure this function has been ran as the root entity
					execute(if entity @s[tag=${tags.root}] at @s) {
						# Add animation tag
						tag @s remove aj.${projectName}.anim.${animation.name}
						# Reset animation time
						scoreboard players set @s ${scoreboards.frame} 0
						# load initial animation frame
						function ${projectName}:animations/${animation.name}/next_frame
						# Reset animation time
						scoreboard players set @s ${scoreboards.frame} 0
					# If this entity is not the root
					} else {
						tellraw @s ${rootExeErrorJsonText.replace('%functionName',`${projectName}:animations/${animation.name}/stop`)}
					}
				}`
			)

			// prettier-ignore
			FILE.push(`# Pauses the animation on the current frame
				function pause {
					# Make sure this function has been ran as the root entity
					execute(if entity @s[tag=${tags.root}] at @s) {
						# Remove animation tag
						tag @s remove aj.${projectName}.anim.${animation.name}
					# If this entity is not the root
					} else {
						tellraw @s ${rootExeErrorJsonText.replace('%functionName',`${projectName}:animations/${animation.name}/pause`)}
					}
				}`
			)

			// prettier-ignore
			FILE.push(`# Resumes the animation from the current frame
				function resume {
					# Make sure this function has been ran as the root entity
					execute(if entity @s[tag=${tags.root}]) {
						# Remove animation tag
						tag @s add aj.${projectName}.anim.${animation.name}
						# Start the animation loop
						execute if score .aj.animation ${scoreboards.animatingFlag} matches 0 run function ${projectName}:animation_loop
					# If this entity is not the root
					} else {
						tellraw @s ${rootExeErrorJsonText.replace('%functionName',`${projectName}:animations/${animation.name}/resume`)}
					}
				}`
			)

			// prettier-ignore
			FILE.push(`# Plays the next frame in the animation
				function next_frame {
					scoreboard players operation .this ${scoreboards.id} = @s ${scoreboards.id}
					execute as @e[type=${entityTypes.boneRoot},tag=${tags.allBones},distance=..${maxDistance}] if score @s ${scoreboards.id} = .this ${scoreboards.id} run {

						${'say Animation tree goes here'}
						# execute if entity @s[tag=aj.example.head] run say Animation tree goes here

						execute store result entity @s Air short 1 run scoreboard players get @s ${scoreboards.frame}
					}

					# Increment frame
					scoreboard players add @s ${scoreboards.frame} 1
					# Let the anim_loop know we're still running
					scoreboard players set .aj.animation ${scoreboards.animatingFlag} 1
				}`
			)

			// prettier-ignore
			FILE.push(`# Performs a loop mode action depending on what the animation's configured loop mode is
				function end {
					# Play Once
					execute if score @s ${thisAnimationLoopMode} matches 0 run {
						function ${projectName}:animations/${animation.name}/stop
					}
					# Hold on last frame
					execute if score @s ${thisAnimationLoopMode} matches 1 run {
						function ${projectName}:animations/${animation.name}/pause
					}
					# loop
					execute if score @s ${thisAnimationLoopMode} matches 2 run {
						scoreboard players set @s ${scoreboards.frame} 0
					}
				}
			`)

			FILE.push(`}`)
		}

		FILE.push(`}`)
	}

	return fixIndent(FILE)
}

async function animationExport(data: any) {
	const mcFile = await createMCFile(
		data.bones,
		data.models,
		data.animations,
		data.settings,
		data.variantModels,
		data.variantTextureOverrides,
		data.variantTouchedModels
	)

	if (!data.settings.animatedJava_exporter_animationExporter.mcbFilePath) {
		let d = new Dialog({
			title: translate(
				'animatedJava_exporter_animationExporter.popup.error.mcbFilePathNotDefined.title'
			),
			id: '',
			lines: translate(
				'animatedJava_exporter_animationExporter.popup.error.mcbFilePathNotDefined.body'
			)
				.split('\n')
				.map((line: string) => `<p>${line}</p>`),
			onConfirm() {
				d.hide()
			},
			onCancel() {
				d.hide()
			},
		}).show()
		throw new CustomError({ silent: true })
	}

	console.log('mcFile:', mcFile)
	Blockbench.writeFile(
		data.settings.animatedJava_exporter_animationExporter.mcbFilePath,
		{
			content: mcFile,
			custom_writer: null,
		}
	)

	Blockbench.showQuickMessage('Model Exported Successfully')
}

const Exporter = (AJ: any) => {
	AJ.settings.registerPluginSettings(
		'animatedJava_exporter_animationExporter',
		{
			rootEntityType: {
				type: 'text',
				default: 'minecraft:marker',
				populate() {
					return 'minecraft:marker'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			markerArmorStands: {
				type: 'checkbox',
				default: true,
				populate() {
					return true
				},
				isValid(value: any) {
					return typeof value === 'boolean'
				},
			},
			modelTag: {
				type: 'text',
				default: 'aj.%projectName',
				populate() {
					return 'aj.%projectName'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			rootTag: {
				type: 'text',
				default: 'aj.%projectName.root',
				populate() {
					return 'aj.%projectName.root'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			allBonesTag: {
				type: 'text',
				default: 'aj.%projectName.bone',
				populate() {
					return 'aj.%projectName.bone'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			boneModelDisplayTag: {
				type: 'text',
				default: 'aj.%projectName.bone_display',
				populate() {
					return 'aj.%projectName.bone_display'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			individualBoneTag: {
				type: 'text',
				default: 'aj.%projectName.bone.%boneName',
				populate() {
					return 'aj.%projectName.bone.%boneName'
				},
				isValid(value: any) {
					return value != ''
				},
				isResetable: true,
			},
			internalScoreboardObjective: {
				type: 'text',
				default: 'aj.i',
				populate() {
					return 'aj.i'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			idScoreboardObjective: {
				type: 'text',
				default: 'aj.id',
				populate() {
					return 'aj.id'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			frameScoreboardObjective: {
				type: 'text',
				default: 'aj.frame',
				populate() {
					return 'aj.frame'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			animatingFlagScoreboardObjective: {
				type: 'text',
				default: 'aj.%projectName.animating',
				populate() {
					return 'aj.%projectName.animating'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			animationLoopModeScoreboardObjective: {
				type: 'text',
				default: 'aj.%projectName.%animationName.loopMode',
				populate() {
					return 'aj.%projectName.%animationName.loopMode'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			exportMode: {
				type: 'select',
				default: 'mcb',
				options: {
					vanilla:
						'animatedJava_exporter_animationExporter.setting.exportMode.vanilla.name',
					mcb: 'animatedJava_exporter_animationExporter.setting.exportMode.mcb.name',
				},
				populate() {
					return 'mcb'
				},
				isValid(value: any) {
					return value != ''
				},
			},
			mcbFilePath: {
				type: 'filepath',
				default: '',
				props: {
					dialogOpts: {
						defaultPath: Project.name + '.mc',
						promptToCreate: true,
						properties: ['openFile'],
					},
				},
				populate() {
					return ''
				},
				isValid(value: any) {
					return true
				},
				isVisible(settings: any) {
					return (
						settings.animatedJava_exporter_animationExporter
							.exportMode === 'mcb'
					)
				},
				dependencies: [
					'animatedJava_exporter_animationExporter.exportMode',
				],
			},
			dataPackPath: {
				type: 'filepath',
				default: '',
				props: {
					target: 'folder',
					dialogOpts: {
						promptToCreate: true,
						properties: ['openDirectory'],
					},
				},
				populate() {
					return ''
				},
				isValid(value: any) {
					return true
				},
				isVisible(settings: any) {
					return (
						settings.animatedJava_exporter_animationExporter
							.exportMode === 'vanilla'
					)
				},
				dependencies: [
					'animatedJava_exporter_animationExporter.exportMode',
				],
			},
		}
	)
	AJ.registerExportFunc('animationExporter', function () {
		AJ.build(
			(data: any) => {
				console.log('Input Data:', data)
				animationExport(data)
			},
			{
				generate_static_animation: true,
			}
		)
	})
}
if (Reflect.has(window, 'ANIMATED_JAVA')) {
	Exporter(window['ANIMATED_JAVA'])
} else {
	// @ts-ignore
	Blockbench.on('animated-java-ready', Exporter)
}
